// envembedgen reads .env from the repo root and generates internal/envembed/embed.go
// so OAuth client/secret are compiled into the binary. Run via: go generate ./cmd/monadscli
package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

var keys = []string{
	"LUCID_OAUTH_CLIENT_ID",
	"LUCID_OAUTH_CLIENT_SECRET",
	"LUCID_OAUTH_REDIRECT_URL",
	"LUCID_OAUTH_SCOPES",
	"LUCID_OAUTH_PROMPT",
	"LUCID_OAUTH_AUTH_URL",
	"LUCID_OAUTH_TOKEN_URL",
	"LUCID_OAUTH_STATE",
}

func main() {
	root := findModuleRoot()
	envPath := filepath.Join(root, ".env")
	vals := map[string]string{}
	for _, k := range keys {
		vals[k] = ""
	}
	if _, err := os.Stat(envPath); err == nil {
		var parseErr error
		vals, parseErr = parseEnv(envPath)
		if parseErr != nil {
			fmt.Fprintf(os.Stderr, "envembedgen: read %s: %v\n", envPath, parseErr)
			os.Exit(1)
		}
	}
	outPath := filepath.Join(root, "internal", "envembed", "embed.go")
	if err := os.MkdirAll(filepath.Dir(outPath), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "envembedgen: %v\n", err)
		os.Exit(1)
	}
	if err := writeEmbed(outPath, vals); err != nil {
		fmt.Fprintf(os.Stderr, "envembedgen: %v\n", err)
		os.Exit(1)
	}
}

func findModuleRoot() string {
	dir, _ := os.Getwd()
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "."
}

func parseEnv(path string) (map[string]string, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	vals := make(map[string]string)
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		line := strings.TrimSpace(sc.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		idx := strings.Index(line, "=")
		if idx < 0 {
			continue
		}
		key := strings.TrimSpace(line[:idx])
		val := strings.TrimSpace(line[idx+1:])
		vals[key] = unquote(val)
	}
	return vals, sc.Err()
}

func unquote(s string) string {
	if s == "" {
		return ""
	}
	if len(s) >= 2 && (s[0] == '"' || s[0] == '\'') {
		if v, err := strconv.Unquote(s); err == nil {
			return v
		}
	}
	return s
}

func writeEmbed(path string, vals map[string]string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Fprint(f, `// Code generated by cmd/envembedgen. Do not edit.
// Run: go generate ./cmd/monadscli
package envembed

`)
	comments := map[string]string{
		"LUCID_OAUTH_CLIENT_ID":     "Lucid OAuth client ID (from .env at build time).",
		"LUCID_OAUTH_CLIENT_SECRET": "Lucid OAuth client secret (from .env at build time).",
		"LUCID_OAUTH_REDIRECT_URL":  "Lucid OAuth redirect URL (from .env at build time).",
		"LUCID_OAUTH_SCOPES":        "Lucid OAuth scopes (from .env at build time).",
		"LUCID_OAUTH_PROMPT":        "Lucid OAuth prompt (from .env at build time).",
		"LUCID_OAUTH_AUTH_URL":      "Lucid OAuth auth URL (from .env at build time).",
		"LUCID_OAUTH_TOKEN_URL":     "Lucid OAuth token URL (from .env at build time).",
		"LUCID_OAUTH_STATE":         "Lucid OAuth state (from .env at build time).",
	}
	for _, k := range keys {
		v := vals[k]
		comment := comments[k]
		if comment == "" {
			comment = k
		}
		fmt.Fprintf(f, "// %s\nvar %s = %s\n\n", comment, goVarName(k), strconv.Quote(v))
	}
	return nil
}

func goVarName(envKey string) string {
	switch envKey {
	case "LUCID_OAUTH_CLIENT_ID":
		return "LucidOAuthClientID"
	case "LUCID_OAUTH_CLIENT_SECRET":
		return "LucidOAuthClientSecret"
	case "LUCID_OAUTH_REDIRECT_URL":
		return "LucidOAuthRedirectURL"
	case "LUCID_OAUTH_SCOPES":
		return "LucidOAuthScopes"
	case "LUCID_OAUTH_PROMPT":
		return "LucidOAuthPrompt"
	case "LUCID_OAUTH_AUTH_URL":
		return "LucidOAuthAuthURL"
	case "LUCID_OAUTH_TOKEN_URL":
		return "LucidOAuthTokenURL"
	case "LUCID_OAUTH_STATE":
		return "LucidOAuthState"
	}
	return envKey
}
